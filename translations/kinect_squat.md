## 파이썬을 이용한 운동 자세 즉석 평가

### 소개 

건강한 라이프스타일은 평범한 운동에 달려있다. 그러나 많은 훈련자들은 올바르지 못한 운동 자세로 고통받고 있고, 부상의 위험성을 늘이며 운동이 주는 건강의 이득을 감소시키고 있다. 올바른 자세의 정립은 일반적으로 퍼스널 트레이너가 필요하다. 우리는 그것을 머신러닝으로 해결하고자 한다.

우리는 일반적인 하체운동인 맨몸스쿼트에 집중하여 이 문제를 해결하고자 한다. 우리의 목적은 Kinect v2 에서 얻어진 움직임 데이터를 이용하여 훈련자가 어떠한 자세의 측면을 더욱 향상시킬 수 있을지 예측하는것이다.

우리는 독립형 binary 나 다항 classifier을 만들기 위해 스쿼트 구성요소 classifier 묶음 (깊이, 무릎이 발끝을 넘지 않는지 등등의 classifier)을 사용하고, 운동 자세의 구성요소가 좋은지 나쁜지 판별할 수 있다. (다항 classifier 에서는 자세의 어떤 면에서 나쁜지) 

또한 우리는 우리의 시스템이 다른 운동에서도 쉽게 적용될 수 있음을 보이기 위해 푸시업 자세 평가도 지원하므로서 분류 파이프라인을 확장할 것이다. 

### 관련된 작업들 

키넥트는 이미 재활운동 분야의 자세 분석에서도 쓰이고 있고, 어느정도의 성공을 거두었다. 그러한 실험들은 운동들을 분류했으며, 키넥트에서 제공하는 골격 좌표를 매핑하여 자동화된 데이터 수집 도구로서 활용되었다.
그러나 이러한 형태의 데이터 수집은 운동 동작을 잘 하고 있는지, 못하고 있는지 등의 특성을 분석하여 실시간 피드백을 제공하지 않으며. 단지 동작의 여러 반복수의 Post-Processing (후처리) 만 가능하게 할 뿐이다.

최근 나이키와 마이크로소프트에서 키넥트를 이용하여 운동 동작을 점수로 평가받는 운동 게임을 만들었다. 그러나 이 플랫폼은 다양한 사이즈의 사용자를 가지고 있으면서, 여러 사이즈를 고려한 좋은 동작의 예시들을 일반화하여 고려하지 않고 하나의 이상적인 자세의 골격 데이터와 패턴 매칭을 하는 방식을 적용했다. 게다가 이 플랫폼은 1개의 갯수에서의 좋은 자세보다는, 사용자가 운동 갯수를 늘리는것을 더 강조했다. 이러한 방식은 운동 자세의 결점을 발견하는 데에는 도움이 되지 않는다.

키넥트는 몸 전체에 걸쳐 다양한 골격 좌표를 얻을 수 있어서 태권도나 무술 훈련 시스템을 디자인하는데에도 도구가 되어 왔다. 그러나 이러한 접근들은 단지 녹화된 프레임과의 유사도를 측정하고, 일일히 수동적으로 허용 오차를 설정하여 무술 테크닉이 좋은 자세인지 나쁜 자세인지 시뮬레이션한다. 그러므로 이러한 시스템은 다양한 크기에 걸친 훈련자들의 광범위한 특성을 쉽게 일반화하지 못한다.

**머신러닝** 또한 인간의 동작 인식과 분류를 위한 골격 데이터를 추출하는데에 사용되어왔다. 관절 요소와 관련하여 동작 어휘를 표현함으로써, Kinect 스트림(연속) 데이터를 개별 동작으로 분석되었고, 각각의 동작은 골격 좌표 구성요소 레벨로서 분류되었다. 이륙 중 사용된 airplane gesture(?) 를 분류하는 연구 사례에서, 서포트 벡터 머신(svm) 과 의사결정 트리(Decision Tree)는 다양한 주제에 걸쳐 적절한 분류에 성과가 있는 것으로 입증되었다.  
특히 공간 문제의 유사성을 고려할 때 (일반적으로 키넥트 스트림을 개별 요소 구성 단위로 분류하는 것) 이러한 접근방식의 성공은 키넥트 기반 운동동작 분석 시스템을 디자인하는데 동기를 부여해 주었다. 
Activity Recognition 은 역도 운동동작 분석에서 이용되어 왔지만, 정확한 피드백을 위해 다양한 웨어러블 장비가 필요했다. 우리의 접근방식은 키넥트를 유일한 비침습 센서(몸을 건들지 않는) 로 사용하여, 사용자에게 동작 갯수 하나당의 피드백을 제공하고. 다양한 표준 운동에 대한 파이프라인을 가능하게 하는 것을 목표로 한다.


### 데이터셋과 Feature
우리 목표의 참신함 때문에, 우리는 프로젝트에 사용할 적절한 데이터셋을 찾을 수 없었다. 우리는 40명에 가까운 지원자로부터 250개의 스쿼트 데이터와 100개의 푸시업 데이터를 수집하고 라벨을 붙였다. 이를 위해 우리는 키넥트 v2 를 사용하여 10개의 스쿼트와 푸시업을 녹화했고 25개 관절의 x,y,z 공간좌표를 추출했다.
우리는 raw 한 시간 연속 데이터를 개별 반복으로 분할하는 알고리즘을 작성했다. 이 분할 후, 각 반복을 x,y,z 축에 대한 단위 범위가 있는 좌표계로 표준화했다. 우리는 각 반복의 라벨을 우리가 설정한 8개의 컴포넌트 classifier 에 해당하는 8개의 카테고리로 분류하였다. 이중 무릎이 발끝을 넘지 않는지, 고관절과 무릎이 동시에 접히는지, 스쿼트 깊이, 척추 각도와 고관절 각도, 스탠스 : 5가지 컴포넌트가 유용하다고 밝혀졌다. 불일치를 최소화하기 위해 동일한 검토자가 컴포넌트의 모든 라벨에 대해 책임졌다.

<img width="798" alt="스크린샷 2019-08-23 오전 11 43 01" src="https://user-images.githubusercontent.com/26560119/63563268-78468100-c59b-11e9-948e-2dc24aa9d724.png">

Feature 을 추출하기 위해 주어진 반복에서 r-discrete frames 을 선택하고, 해당 프레임의 관절 좌표를 사용하여 다양한 Feature를 뽑아낸다. 여기서 r은 각 컴포넌트 classifer에 대해 별도로 조정한 프레임 분석용 하이퍼 파라미터이다. 우리는 피트니스 서적을 기반으로 각 컴포넌트의 feature 들을 디자인했다. 우리는 우리의 전체 feature set에서 가장 잘 동작하는 컴포넌트 classifier 들을 발견했다. 반면 나머지 classifier 들은 우리가 해당 컴포넌트에 대해서 특별히 디자인한 feature 들에서 잘 동작했다. 이중 공통 feature는 주요 프레임(예를 들어 스쿼트 최하지점)에서의 관절간 각도, 시간에 따른 각도 변화, 주요 프레임에서 스케일링 된 관절의 위치, 시간에 따른 위치변화 그리고 관절간 거리였다. 우리가 확보한 모든 데이터에서 각각의 feature 의 값 집합은 단위 분산 및 0 평균으로 정규화 되었다. 

<img width="821" alt="스크린샷 2019-08-23 오전 11 43 07" src="https://user-images.githubusercontent.com/26560119/63563269-78df1780-c59b-11e9-8b9c-3b3dcce474a4.png">


### 방법론 
몇가지 다른 학습 모델을 실험한 후에, 우리는 각 Component classifier에 대해 사용할 한, 두개 정도의 학습 모델을 정했다. (로지스틱 회귀, 의사결정 트리)  
로지스틱 회귀는 선형회귀 모델의 결과를 로지스틱 함수를 이용해 {0,1} 범위로 압축한다. (로지스틱 함수는 이진 분류의 경우 로지스틱 함수 결과가 0.5 이상이면 양수로 분류되며, 그렇지 않으면 음수로 분류된다) 그리고 우리는 오버피팅 문제를 방지하기 위해 로지스틱 회귀와 함께 L1 정규화를 사용한다. (우리 테스트에서는 L2 정규화보다 L1 정규화가 더 좋은 성능을 발휘했다) 로지스틱 회귀 분석에는 바이너리와 K class 들에 일반화된 가설함수를 사용했고, L1 정규화는 소프트맥스 함수를 통해 정의되었다 :

<img width="805" alt="스크린샷 2019-08-23 오전 11 43 13" src="https://user-images.githubusercontent.com/26560119/63563271-78df1780-c59b-11e9-92ab-716c7dbc4698.png">

성분 분류기에 따라 λ값이 다른 L1 정규화를 사용하는 이항목표 함수(binary objective function)는 다음과 같다:

<img width="683" alt="스크린샷 2019-09-23 오후 9 22 28" src="https://user-images.githubusercontent.com/26560119/65425142-4483a300-de48-11e9-97f6-4be478746aa7.png">

우리는 [무릎이 발끝을 넘지 않는지], [고관절과 무릎이 동시에 접히는지] 이 두개의 컴포넌트 classfier 에 의사결정 트리를 사용했다. 의사결정 트리는 각 노드의 속성값에 따라 데이터를 하위 집합(subset) 으로 반복적으로 분할하여 학습한다. subset에 있는 나머지 데이터가 모두 특정 노드에서 동일한 값을 갖는 경우, 반복은 끝나고 해당 노드는 Leaf Node 가 된다. 테스트시 의사결정 트리의 데이터 흐름은 관련된 변수의 속성 값에 따라 각 노드의 왼쪽 또는 오른쪽으로 분기하는 의사결정 트리를 통해 결정된다. 이 과정의 끝에서 Leaf Node 의 클래스 라벨은 이 classfier 의 결과물이 된다.  
의사결정 트리는 어떻게 각 노드의 데이터 분할 방법을 결정할까? Scikit-learn 의사결정트리의 분할 방법의 구현은 집합에서 임의로 선택한 요소가 subset의 라벨 분포를 기준으로 랜덤하게 라벨을 부착할 경우 얼마나 자주 잘못 라벨이 지정되는지 측정하는 지니 불순도 (Gini impurity) 이다. 이것은 회귀 문제에는 적합하나 우리가 직면한 분류 문제에는 좋은 성능을 발휘하지 못했다. 대신, 우리는 더 많은 정보 획득을 위해 분할 방법으로 엔트로피를 사용하기로 했다 :

<img width="787" alt="스크린샷 2019-08-23 오전 11 43 32" src="https://user-images.githubusercontent.com/26560119/63563273-78df1780-c59b-11e9-8108-b8376ba5c158.png">

여기서 함수는 i 번째 항목이 선택될 확률이다. 직관적으로 이 측정 지표는 그 데이터에 대해 가장 유익한 metric 에 근거하여 데이터를 분할한다. 여기서 가장 유익한 metric 은 정보 이론적 용어에서 정의된다. 이것은 트리 내의 상호 정보가 극대화됨을 의미하며, 이는 한 클래스가 훈련 데이터셋을 지배하는 분류 문제에 대해 지니 불순도를 사용하는 방법보다 더 나은 결과를 산출한다. (우리는 positive label 이 부족했기 때문에 이러한 케이스가 발생)  
또한 의사결정 트리 classifier 의 경우, 우리는 최대깊이 레벨을 3으로 설정하는데, 이는 트리 레벨이 너무 깊게 설정되지 않도록 방지함으로써 오버피팅을 방지하는데 도움이 된다.

### 실험적 결과와 분석 
각 Classifier 에 대해 SVM, 로지스틱 회귀 분석, 의사결정 트리 및 랜덤 포레스트를 이용한 실험을 실시했다. 로지스틱 회귀와 SVM 을 위해 각 Classifier 에 대해 이 모델들의 하이퍼 파라미터(Hyperparameter)를 독립적으로 튜닝하고 정규화를 수행했으며, 오버피팅을 줄이기 위한 노력으로 랜덤 포레스트와 의사결정 트리에 대한 max-depth 하이퍼 파라미터를 튜닝하며 서로 다른 분할 방법을 통해 실험했다. 최적화된 하이퍼 파라미터를 가진 각 모델의 성능은 아래 표에 나와있다.

우리는 스쿼트 구성요소들애 대해 각각 테스트 했다. (무슨 말인지 모르겠음..) *For each, we ran LOOCV on our various classifiers with little to no hyper parameter tuning aside from varying resolution and component­specific features vs the entire feature set.*  
우리는 최소 4개의 프레임(r=4)에서 최대 200개의 프레임(r= 200개)까지 테스트했다. 후자는 종종 특정 프레임에 대해 두 번 카운팅하는 결과를 초래하며 feature 들을 추출하는 데 6분에서 8분 정도 걸릴 것이다. 학습(Training) 시간은 최대 개수의 프레임과 feature 을 사용해도 일반적으로 2분 미만으로 진행되었고, 분류 또한 즉각적이였다. LOOCV가 선택된 이유는 우리의 학습 데이터셋 크기가 작기 때문이였다.

우리는 먼저 r 값을 달리 하면서 프레임에서 추출한 컴포넌트별 feature 들을 대상으로 추론 평가 (inference evaluation) 를 반복했다. 마찬가지로, r 프레임들에서 추출한 모든 feature 을 가지고 classifier 를 실행했다. 이것은 컴포넌트 분류가 단지 컴포넌트 기반 feature 만을 사용하여 더 잘 분류되는지, 아니면 우리가 원래 구성한 feature 들의 전체 세트를 이용하여 더 잘 분류되는지에 대한 초기 직관을 우리에게 줄 것이였다. 우리는 주로 F1 score 과 정확도를 비교하면서 우리 모델들의 성능을 측정하였다.

이 모든 것은 컴포넌트 기반 feature 을 사용할지 아니면 전체 feature 세트를 사용할지 여부를 결정하는 데 도움이 되었으며, 이는 일반적으로 일부 초기 실행 후에 빠르게 명확해질 수 있었다. 그런 다음 r의 모든 반복에 걸쳐 현재 지정된 feature 세트를 사용하여 classifier 의 개별 성능을 자세히 살표볼 수 있었다. 이를 통해 우리는 원래의 classifier 세트를 좁힌 다음 최적의 솔루션에 도달할 때까지 앞서 언급한 하이퍼 파라미터를 조정하면서 가장 유망한 모델들을 테스트할 수 있었다.

<img width="784" alt="스크린샷 2019-08-23 오전 11 43 42" src="https://user-images.githubusercontent.com/26560119/63563274-7977ae00-c59b-11e9-8972-8e5c20860b87.png">


<img width="846" alt="스크린샷 2019-08-23 오전 11 43 48" src="https://user-images.githubusercontent.com/26560119/63563276-7977ae00-c59b-11e9-9f00-a5cabc589d95.png">

우리가 실험 결과에서 얻을 수 있는 몇 가지 흥미로운 해결책들이 있다. 첫째, 대부분의 컴포넌트 기반 classifier 의 경우 테스팅 오차가 학습 오류보다 확실히 낮다는 것을 관찰했다. 이것은 데이터 세트의 몇 가지 도전을 비추어 준다 : 즉, 우리는 데이터가 극도로 제약되어 있다. '무릎이 발끝을 넘는지' 및 '엉덩이와 무릎이 동시에 펴지는지' 와 같은 몇몇 그래프에서 F1 테스트 파포먼스는 아직 평준화?(leveling out) 에 근접하지 않은 것으로 보이며, 이는 더 많은 훈련 데이터가 눈에 띄게 성능을 향상시킬 수 있을 것임을 시사한다. 이 프로젝트 내내 오버피팅 해결은 지속적인 과제였다. 예를 들어, SVM은 과도한 정규화 페널티에도 불구하고 종종 우리의 학습 데이터에 대해 오버피팅이 발생하므로, SVM 테스트 결과는 의사결정 트리나 로지스틱 회귀 분석과 비교할 가능한 F1 점수를 제시하지 못한다. 정규화 상수가 SVM 에 얼마나 민감한 지 알고 있으면 우리가 상수들 사이에 충분히 세밀한 검색을 하지 않았을 가능성이 있다

우리는 오버피팅 문제를 해결하기 위해 몇 가지 접근법을 시도했다. 각 classifier 에 대한 로지스틱 회귀 분석 모델에 대해 L1과 L2 정규화를 모두 실험한 결과, L1이 여러 모델에서 가장 잘 수행되었다. 이는 feature vector 가 다소 희박한 탓일 가능성이 높다. 원래 우리는 각 컴포넌트 classifier 대해 모든 feature 을 사용했지만, 나중에 각 컴포넌트 classfier 에 대한 대부분의 feature 을 제거하여 각 컴포넌트 classifier 에 대한 가설 클래스 (hypothesis class) 를 제한하려고 했다. 이는 스쿼트 깊이와 같은 상태 기반 컴포넌트 classifier 에게 잘 먹혔으며, 이는 거의 전적으로 각 반복의 bottom frame (가장 하위의 자세를 나타내는 프레임, 스쿼트 앉았을때 자세) 에 의해 결정된다. 우리는 'knees over-toes' 와 같은 몇몇 가지들에 대해서는 모든 feature 을 유지하는 것이 더 나은 성능을 제공한다는 것을 발견했다. 이러한 차이가 발생하는 것에 대한 우리의 가설은 두 가지다.

1) 상태 기반 컴포넌트는 관련 frame 의 관련 관절의 즉각적인 위치에 의해 더 단순하고 일반적으로 결정되는 반면, '엉덩이와 무릎의 동시 굽힘' 과 같은 지속성에 의존하는 컴포넌트는 시간이 지남에 따라 결정되며 대개 완전한 신체 부위의 참여가 필요하다.

2) 일부 컴포넌트에 대한 성능은 해부학과 물리학의 기본 법칙에 의해 다른 컴포넌트에 영향을 미친다. 예를 들어, 스쿼트 시 무릎이 발끝 밖으로 나가지 않게 하면서 등을 수직으로 유지하는 것은 거의 불가능하다 (그리고 좋은 자세가 아니다) 이렇게 하려고 한다면 거의 대부분의 사람들이 뒤로 넘어질 것이다. 그러므로 우리가 원래 등-고관절 각도 classifier 을 염두에 두고 쓴 feature 들은 무릎이 '발끝을 넘지 않는지 classifier' 과도 관련이 있었다.

이 분석은 이 프로젝트 전반에 걸쳐 우리의 domain-specific 한 지식의 가치를 보여주는 한 가지 예이다. 운동 관련 문헌과 데이터 셋의 요점을 면밀히 연구함으로써 우리는 성능 향상에 몇 가지 이점을 얻었다. 예를 들어, 우리가 학습 데이터가 제약되어 있다는 것을 안다면, 우리는 특징 추출에 사용하던 state 를 다시 생각하게 된다. 우리는 원래 해상도 r = 4 로 feature 을 추출하는 것만을 고려했다. 그러나 초기 실험을 실행하고 더 많은 데이터가 필요하다는 결론을 내린 후, 단순히 해상도 크기를 늘리고 더 이상 반복 당 프레임을 너무 많이 사용하지 않음으로써 새로운 동작 녹화 없이 우리의 효과적인 기여 데이터 양을 상당히 증가시킬 수 있다는 것을 관찰했다. 실험은 시간이 지남에 따라 벌생되는 컴포넌트에는 고 해상도가 더 낫고, 저해상도는 시간에 따른 변화에덜 의존하는 단순한 구성요소에 탁월하다는 것을 확인하였다.

그러나 우리는 여전히 개선의 여지가 크다. 우리는 오류 분석을 위해 위의 실험들 중 몇 가지를 실행했고, 우리는 다른 요소들이 개선을 위해 다른 조정이 필요할 수 있다는 것을 알 수 있었다. 예를 들어, 우리의 테스트 F1 점수는 '팔꿈치 각도'와 '고관절-무릎 동시 굽힘' 에서 비교적 낮았다. 우리는 이 컴포넌트들에 대한 학습 label 을 살펴봤고, 학습 세트에서 0 이 아닌 label (nonzero labels) 의 개수가 가장 적은 경향이 있음을 관찰했다. 이것은 우리가 올바르지 않은 운동 자세에 대한 더 많은 예시들을 얻는 것이 이 분야에서 우리가 발전하는 데 도움이 될 것이라는 것을 암시한다. 성능 측정을 위해 LOOCV를 사용하기 때문에 문제가 특히 심각할 수 있다. 팔굽혀펴기에서의 팔꿈치 각도의 경우, 18명의 팔굽혀펴기 지원자 중 단 3명만이 0이 아닌 라벨 (nonzero labels) 을 받은 적이 있다. 이 세 명 중 한 명을 훈련 단계에서 제외시키면 팔꿈치 각도가 나쁜 예가 17명 중 두 명밖에 없다. 각 세트에는 10회 분량의 푸시업이 포함되어 있지만, 기계 학습으로 강력한 결과를 얻을 수 있는 데이터로는 충분하지 않다.

데이터 부족은 우리만의 문제가 아니다. 이미 논의된 명백한 과적합 문제와 달리, 우리의 스쿼트 깊이 classifier 은 상대적으로 일관된 학습 및 테스트 성능을 가지고 있다. 하지만 학습 성능은 그룹에서 최 하위다. 왜 그럴까? 자세히 살펴보니, 우리는 스쿼트 깊이가 우리가 일관성 있게 라벨링 하는데 있어서 가장 어려운 컴포넌트라는 것을 깨달았다. 정확한 레이블링을 확신하지 못하는 애매한 사례가 너무 많아서 (스쿼트 깊이가 너무 깊거나 거의 깊이가 없는 경우) 데이터셋에 잘못된 label 이 여러 개 포함되어 있을 가능성이 있다. 이렇게 하면 학습 정확도가 선형 classifier 와 우리가 선택한 feature 세트로는 100% 가까이 도달할 수 없게 된다. 비선형 classifier라 할지라도, Rote memorization 없이는 100% 훈련 정확도를 달성할 수 없을 것이다. 따라서 향후 개선을 위해 우리는 더 강력한 라벨링 기법으로 실험할 것이다. 예를 들어, 각 스쿼트가 여러 사람에 의해 라벨링되는지 확인하고 중간 단계의 레이블을 부착하거나 전문 피트니스 전문가를 고용하여 라벨링을 직접 수행하도록 하는 방법들이 있을 것이다.

또 다른 오류 원인은, 키넥트의 노이즈 때문이였다. 원시의 골격 데이터를 검사해본 결과, Kinect는 관절이 해부학적으로 불가능함에도 불구하고 몇몇 프레임에서 종종 측면으로 몇 인치 왜곡되었다가 다시 돌아오는 등의 현상이 있었다. 우리는 원래 여러 컴포넌트 classifier 의 feature 으로서 관절 위치를 다양화했는데, 왜냐하면 사람들이 스쿼트나 팔굽혀펴기를 하는 동안 몸이 흔들리는 것은 문제가 있다는 것을 나타내기 때문이며, 때로는 나쁜 자세의 여러 가지 문제가 필연적으로 발생하는 것을 의미하기 때문이다. 이 오류의 원인이 발견되고 난 뒤 우리는 대부분의 feature set 에서 분산(variance) 을 제거하였고 성능이 개선되었다. (또한 과적응을 시사함: 관절 분산(joint variance) 이 주로 키넥트의 노이즈를 반영하고, 잘못된 동작에 대한 의미 있는 표시가 아니라면, 우리는 해당 feature 의 가중치가 0에 가깝게 될 것으로 예상하며, 따라서 그것을 제거한 후에 성능 개선 정도를 알아차리지 못할 것이다. 우리가 개선을 발견했다는 사실은 그것이 아니라는 것을 시사하며, 따라서 우리는 적어도 랜덤한 키넥트 소음에 대해서는 적합하다는 것을 의미한다.) 센서 노이즈는 특히 푸시업 분류에 관해 어려움이 있었다. Kinect는 측면 각도에서 skeleton 을 예측하도록 설계되지 않았기 때문에 관절 좌표가 특히 불안정하기 때문이다. 우리는 원래 스쿼트와 팔굽혀펴기에 사용하려고 했던 모든 부품을 버려야 했다. 왜냐하면 머리 관절에 대해 키넥트에서 나온 데이터가 많이 부정확 했기 때문이다.

놀랍게도, 우리는 또한 의사결정 트리를 최적의 모델로 판단하는 컴포넌트 classifier 에 의사결정 트리 대신 랜덤 포레스트 기법을 사용할 때 테스팅 오차가 증가하는 것을 관찰했다. 랜덤 포레스트는 내부적으로 의사결정 트리에 의존하지만 고립된 상태에서의 오버피팅 경향을 교정하기 위하여 여러 트리 사이에 voting (투표?) 메커니즘을 통합하여 우리는 이러한 결과를 예상하지 못했다. 우리는 이 결과가 랜덤 포레스트에 대한 최적의 하이퍼 파라미터 때문이며, 최대 트리 깊이, 노드 분할 및 데이터 샘플링 하이퍼 파라미터를 보다 광범위하게 조정하면 의사결정 트리의 성능을 능가할 수 있을 것으로 예측하고 있다.

### 결론
요약하자면, 우리는 운동 자세 평가를 위한 견고한 파이프라인을 제시하며, 완제품에 가까운 기반 구조와 몇 가지 뚜렷한 운동 자세 평가 컴포넌트에 대한 독립적인 classifier 를 기반으로 한다. 우리는 특히 '무릎은 발끝을 넘지 않는지' '스탠스', '스쿼트 깊이' 등 많은 컴포넌트 classifier 에 있어 유망한 결과를 보여준다. 게다가, 우리는 우리의 접근방식이 완전히 별개의 운동인 푸시업에 대해 적용된 결과를 통해 일반화될 수 있다는 것을 보여준다. 이 작업을 계속하기 위해 우리는 더 많은 학습 데이터를 수집하여 테스트 성능이 어떻게 향상될 것인지 더 잘 알고자 한다. 우리는 또한 더 많은 파라미터 튜닝을 탐구하고 전문적인 라벨링에 시간을 투자하고 싶다. 마지막으로, 실제 세계에서 개인 트레이너가 할 수 있는 것처럼 결과를 특징짓는 영어 문장을 만들기 위해 이러한 컴포넌트 classifier 의 출력에 대해서도 기계 학습을 사용하는 것 또한 흥미로울 것이다.
