## 파이썬을 이용한 운동 자세 즉석 평가

### 소개 

건강한 라이프스타일은 평범한 운동에 달려있다. 그러나 많은 훈련자들은 올바르지 못한 운동 자세로 고통받고 있고, 부상의 위험성을 늘이며 운동이 주는 건강의 이득을 감소시키고 있다. 올바른 자세의 정립은 일반적으로 퍼스널 트레이너가 필요하다. 우리는 그것을 머신러닝으로 해결하고자 한다.

우리는 일반적인 하체운동인 맨몸스쿼트에 집중하여 이 문제를 해결하고자 한다. 우리의 목적은 Kinect v2 에서 얻어진 움직임 데이터를 이용하여 훈련자가 어떠한 자세의 측면을 더욱 향상시킬 수 있을지 예측하는것이다.

우리는 독립형 binary 나 다항 classifier을 만들기 위해 스쿼트 구성요소 classifier 묶음 (깊이, 무릎이 발끝을 넘지 않는지 등등의 classifier)을 사용하고, 운동 자세의 구성요소가 좋은지 나쁜지 판별할 수 있다. (다항 classifier 에서는 자세의 어떤 면에서 나쁜지) 

또한 우리는 우리의 시스템이 다른 운동에서도 쉽게 적용될 수 있음을 보이기 위해 푸시업 자세 평가도 지원하므로서 분류 파이프라인을 확장할 것이다. 

### 관련된 작업들 

키넥트는 이미 재활운동 분야의 자세 분석에서도 쓰이고 있고, 어느정도의 성공을 거두었다. 그러한 실험들은 운동들을 분류했으며, 키넥트에서 제공하는 골격 좌표를 매핑하여 자동화된 데이터 수집 도구로서 활용되었다.
그러나 이러한 형태의 데이터 수집은 운동 동작을 잘 하고 있는지, 못하고 있는지 등의 특성을 분석하여 실시간 피드백을 제공하지 않으며. 단지 동작의 여러 반복수의 Post-Processing (후처리) 만 가능하게 할 뿐이다.

최근 나이키와 마이크로소프트에서 키넥트를 이용하여 운동 동작을 점수로 평가받는 운동 게임을 만들었다. 그러나 이 플랫폼은 다양한 사이즈의 사용자를 가지고 있으면서, 여러 사이즈를 고려한 좋은 동작의 예시들을 일반화하여 고려하지 않고 하나의 이상적인 자세의 골격 데이터와 패턴 매칭을 하는 방식을 적용했다. 게다가 이 플랫폼은 1개의 갯수에서의 좋은 자세보다는, 사용자가 운동 갯수를 늘리는것을 더 강조했다. 이러한 방식은 운동 자세의 결점을 발견하는 데에는 도움이 되지 않는다.

키넥트는 몸 전체에 걸쳐 다양한 골격 좌표를 얻을 수 있어서 태권도나 무술 훈련 시스템을 디자인하는데에도 도구가 되어 왔다. 그러나 이러한 접근들은 단지 녹화된 프레임과의 유사도를 측정하고, 일일히 수동적으로 허용 오차를 설정하여 무술 테크닉이 좋은 자세인지 나쁜 자세인지 시뮬레이션한다. 그러므로 이러한 시스템은 다양한 크기에 걸친 훈련자들의 광범위한 특성을 쉽게 일반화하지 못한다.

**머신러닝** 또한 인간의 동작 인식과 분류를 위한 골격 데이터를 추출하는데에 사용되어왔다. 관절 요소와 관련하여 동작 어휘를 표현함으로써, Kinect 스트림(연속) 데이터를 개별 동작으로 분석되었고, 각각의 동작은 골격 좌표 구성요소 레벨로서 분류되었다. 이륙 중 사용된 airplane gesture(?) 를 분류하는 연구 사례에서, 서포트 벡터 머신(svm) 과 의사결정 트리(Decision Tree)는 다양한 주제에 걸쳐 적절한 분류에 성과가 있는 것으로 입증되었다.  
특히 공간 문제의 유사성을 고려할 때 (일반적으로 키넥트 스트림을 개별 요소 구성 단위로 분류하는 것) 이러한 접근방식의 성공은 키넥트 기반 운동동작 분석 시스템을 디자인하는데 동기를 부여해 주었다. 
Activity Recognition 은 역도 운동동작 분석에서 이용되어 왔지만, 정확한 피드백을 위해 다양한 웨어러블 장비가 필요했다. 우리의 접근방식은 키넥트를 유일한 비침습 센서(몸을 건들지 않는) 로 사용하여, 사용자에게 동작 갯수 하나당의 피드백을 제공하고. 다양한 표준 운동에 대한 파이프라인을 가능하게 하는 것을 목표로 한다.


### 데이터셋과 Feature
우리 목표의 참신함 때문에, 우리는 프로젝트에 사용할 적절한 데이터셋을 찾을 수 없었다. 우리는 40명에 가까운 지원자로부터 250개의 스쿼트 데이터와 100개의 푸시업 데이터를 수집하고 라벨을 붙였다. 이를 위해 우리는 키넥트 v2 를 사용하여 10개의 스쿼트와 푸시업을 녹화했고 25개 관절의 x,y,z 공간좌표를 추출했다.
우리는 raw 한 시간 연속 데이터를 개별 반복으로 분할하는 알고리즘을 작성했다. 이 분할 후, 각 반복을 x,y,z 축에 대한 단위 범위가 있는 좌표계로 표준화했다. 우리는 각 반복의 라벨을 우리가 설정한 8개의 컴포넌트 classifier 에 해당하는 8개의 카테고리로 분류하였다. 이중 무릎이 발끝을 넘지 않는지, 고관절과 무릎이 동시에 접히는지, 스쿼트 깊이, 척추 각도와 고관절 각도, 스탠스 : 5가지 컴포넌트가 유용하다고 밝혀졌다. 불일치를 최소화하기 위해 동일한 검토자가 컴포넌트의 모든 라벨에 대해 책임졌다.

<img width="798" alt="스크린샷 2019-08-23 오전 11 43 01" src="https://user-images.githubusercontent.com/26560119/63563268-78468100-c59b-11e9-948e-2dc24aa9d724.png">

Feature 을 추출하기 위해 주어진 반복에서 r-discrete frames 을 선택하고, 해당 프레임의 관절 좌표를 사용하여 다양한 Feature를 뽑아낸다. 여기서 r은 각 컴포넌트 classifer에 대해 별도로 조정한 프레임 분석용 하이퍼 파라미터이다. 우리는 피트니스 서적을 기반으로 각 컴포넌트의 feature 들을 디자인했다. 우리는 우리의 전체 feature set에서 가장 잘 동작하는 컴포넌트 classifier 들을 발견했다. 반면 나머지 classifier 들은 우리가 해당 컴포넌트에 대해서 특별히 디자인한 feature 들에서 잘 동작했다. 이중 공통 feature는 주요 프레임(예를 들어 스쿼트 최하지점)에서의 관절간 각도, 시간에 따른 각도 변화, 주요 프레임에서 스케일링 된 관절의 위치, 시간에 따른 위치변화 그리고 관절간 거리였다. 우리가 확보한 모든 데이터에서 각각의 feature 의 값 집합은 단위 분산 및 0 평균으로 정규화 되었다. 

<img width="821" alt="스크린샷 2019-08-23 오전 11 43 07" src="https://user-images.githubusercontent.com/26560119/63563269-78df1780-c59b-11e9-8b9c-3b3dcce474a4.png">


### 방법론 
몇가지 다른 학습 모델을 실험한 후에, 우리는 각 Component classifier에 대해 사용할 한, 두개 정도의 학습 모델을 정했다. (로지스틱 회귀, 의사결정 트리)  
로지스틱 회귀는 선형회귀 모델의 결과를 로지스틱 함수를 이용해 {0,1} 범위로 압축한다. (로지스틱 함수는 이진 분류의 경우 로지스틱 함수 결과가 0.5 이상이면 양수로 분류되며, 그렇지 않으면 음수로 분류된다) 그리고 우리는 오버피팅 문제를 방지하기 위해 로지스틱 회귀와 함께 L1 정규화를 사용한다. (우리 테스트에서는 L2 정규화보다 L1 정규화가 더 좋은 성능을 발휘했다) 로지스틱 회귀 분석에는 바이너리와 K class 들에 일반화된 가설함수를 사용했고, L1 정규화는 소프트맥스 함수를 통해 정의되었다.

<img width="805" alt="스크린샷 2019-08-23 오전 11 43 13" src="https://user-images.githubusercontent.com/26560119/63563271-78df1780-c59b-11e9-92ab-716c7dbc4698.png">

우리는 [무릎이 발끝을 넘지 않는지], [고관절과 무릎이 동시에 접히는지] 이 두개의 컴포넌트 classfier 에 의사결정 트리를 사용했다. 의사결정 트리는 각 노드의 속성값에 따라 데이터를 하위 집합(subset) 으로 반복적으로 분할하여 학습한다. subset에 있는 나머지 데이터가 모두 특정 노드에서 동일한 값을 갖는 경우, 반복은 끝나고 해당 노드는 Leaf Node 가 된다. 테스트시 의사결정 트리의 데이터 흐름은 관련된 변수의 속성 값에 따라 각 노드의 왼쪽 또는 오른쪽으로 분기하는 의사결정 트리를 통해 결정된다. 이 과정의 끝에서 Leaf Node 의 클래스 라벨은 이 classfier 의 결과물이 된다.  
의사결정 트리는 어떻게 각 노드의 데이터 분할 방법을 결정할까? Scikit-learn 의사결정트리의 분할 방법의 구현은 집합에서 임의로 선택한 요소가 subset의 라벨 분포를 기준으로 랜덤하게 라벨을 부착할 경우 얼마나 자주 잘못 라벨이 지정되는지 측정하는 지니 불순도 (Gini impurity) 이다. 이것은 회귀 문제에는 적합하나 우리가 직면한 분류 문제에는 좋은 성능을 발휘하지 못했다. 대신, 우리는 더 많은 정보 획득을 위해 분할 방법으로 엔트로피를 사용하기로 했다 :

<img width="793" alt="스크린샷 2019-08-23 오전 11 43 18" src="https://user-images.githubusercontent.com/26560119/63563272-78df1780-c59b-11e9-8a68-6675a81bff25.png">

여기서 함수는 i 번째 항목이 선택될 확률이다. 직관적으로 이 측정 지표는 그 데이터에 대해 가장 유익한 metric 에 근거하여 데이터를 분할한다. 여기서 가장 유익한 metric 은 정보 이론적 용어에서 정의된다. 이것은 트리 내의 상호 정보가 극대화됨을 의미하며, 이는 한 클래스가 훈련 데이터셋을 지배하는 분류 문제에 대해 지니 불순도를 사용하는 방법보다 더 나은 결과를 산출한다. (우리는 positive label 이 부족했기 때문에 이러한 케이스가 발생)  
또한 의사결정 트리 classifier 의 경우, 우리는 최대깊이 레벨을 3으로 설정하는데, 이는 트리 레벨이 너무 깊게 설정되지 않도록 방지함으로써 오버피팅을 방지하는데 도움이 된다.

### 실험적 결과와 분석 
<img width="787" alt="스크린샷 2019-08-23 오전 11 43 32" src="https://user-images.githubusercontent.com/26560119/63563273-78df1780-c59b-11e9-8108-b8376ba5c158.png">

<img width="784" alt="스크린샷 2019-08-23 오전 11 43 42" src="https://user-images.githubusercontent.com/26560119/63563274-7977ae00-c59b-11e9-8972-8e5c20860b87.png">

<img width="846" alt="스크린샷 2019-08-23 오전 11 43 48" src="https://user-images.githubusercontent.com/26560119/63563276-7977ae00-c59b-11e9-9f00-a5cabc589d95.png">